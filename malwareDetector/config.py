"""Load all user defined config and env vars."""

import os
import sys
import logging
import argparse

from pydantic import BaseModel, Extra
from typing import List, Any
from .const import *

class PathConfig(BaseModel):
    '''
    The `PathConfig` class stores the input file path
    and output file path settings for the detector,
    which are obtained from `parameter_parser()`.
    If no additional settings are provided,
    default values will be used.
    '''
    input: str = DEFAULT_INPUT_PATH
    output: str = DEFAULT_OUT_PATH

class ModelConfig(BaseModel):
    '''
    The `ModelConfig` class stores the
    hyperparameters of model for the detector,
    which are obtained from `parameter_parser()`.
    If no additional settings are provided,
    default values will be used.

    If you wish to create a customized parameter,
    please refer to the `set_param` method of
    the `ModelConfig` class.
    '''
    modelName: str = DEFAULT_MODEL_NAME
    dimensions: int = DEFAULT_DIMENSIONS
    workers: int = DEFAULT_WORKERS
    epochs: int = DEFAULT_EPOCHS
    min_count: int = DEFAULT_MIN_COUNT
    wl_iterations: int = DEFAULT_WL_ITERATIONS
    learning_rate: float = DEFAULT_LEARNING_RATE
    down_sampling: float = DEFAULT_DOWN_SAMPLING

    def set_param(self, __name: str, __value: Any):
        if hasattr(self, __name):
            raise AttributeError(f"Parameter {__name} already exists.")
        else:
            setattr(self, __name, __value)

    def del_param(self, __name: str):
        if hasattr(self, __name):
            delattr(self, __name)

class FolderConfig(BaseModel, extra=Extra.allow):
    '''
    The `FolderConfig` class stores the names
    of folders where the stored data is kept.

    If you wish to create a customized folder,
    please refer to the `set_folder` method of
    the `FolderConfig` class.
    '''
    dataset: str = DATASET_DIR
    feature: str = FEATURE_DIR
    vectorize: str = VECTORIZE_DIR
    model: str = MODEL_DIR
    predict: str = PREDICT_DIR
    folder_list: List[str] = [DATASET_DIR, FEATURE_DIR, VECTORIZE_DIR, MODEL_DIR, PREDICT_DIR]

    def __iter__(self):
        return FolderClassIter(self.folder_list)

    def set_folder(self, __name: str, __value: str):
        if hasattr(self, __name):
            raise AttributeError(f"Folder {__name} already exists.")
        else:
            __value = f"./{__value}/"
            setattr(self, __name, __value)
            self.folder_list.append(__value)

    def del_folder(self, __name: str):
        if hasattr(self, __name):
            __value = getattr(self, __name)
            delattr(self, __name)
            if __value in self.folder_list:
                self.folder_list.remove(__value)

class FolderClassIter(object):
    '''
    `FolderClassIter` is an instance of
    an Iterator for `FolderConfig`,
    allowing users to access the contents
    of the folder list in a loop.
    '''
    def __init__(self, folder_list):
        self._folder = folder_list
        self._folder_size = len(folder_list)
        self._current_index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self._current_index < self._folder_size:
            member = self._folder[self._current_index]
            self._current_index += 1
            return member
        raise StopIteration

class Config(BaseModel):
    '''
    The `Config` class stores all the external settings
    for the detector, which are obtained from `parameter_parser()`.
    If no additional settings are provided, default values will be used.

    Main configuration items include:
        `PathConfig`: Stores information related to file paths.
        `FolderConfig`: Contains configurations for folders and directories.
        `ModelConfig`: Includes settings specific to the model.
        `classify`: Determines whether the task is malware family classification or simple malware detection.
    '''
    path: PathConfig = PathConfig()
    folder: FolderConfig = FolderConfig()
    model: ModelConfig = ModelConfig()
    classify: bool = DEFAULT_CLASSIFY

def parameter_parser(config: Config) -> Config:
    '''
    A method for parsing command line parameters
    using `python argparse`. If not specified in
    the command line, it will use the default
    values set in `const.py`.
    '''
    parser = argparse.ArgumentParser(description="Parse command line parameters.")

    parser.add_argument("--input-path","-i",
                        dest="input_path",
                        nargs="?",
                        default=DEFAULT_INPUT_PATH,
                        help="Input folder with jsons."
                        )

    parser.add_argument("--output-path","-o",
                        dest="output_path",
                        nargs="?",
                        default=DEFAULT_OUT_PATH,
                        help="Embeddings path."
                        )

    parser.add_argument("--dimensions",
                        dest="dimensions",
                        type=int,
                        default=DEFAULT_DIMENSIONS,
                        help="Number of dimensions. Default is 128."
                        )

    parser.add_argument("--workers",
                        dest="workers",
                        type=int,
                        default=DEFAULT_WORKERS,
                        help="Number of workers. Default is 4."
                        )

    parser.add_argument("--epochs",
                        dest="epochs",
                        type=int,
                        default=DEFAULT_EPOCHS,
                        help="Number of epochs. Default is 10."
                        )

    parser.add_argument("--min-count",
                        dest="min_count",
                        type=int,
                        default=DEFAULT_MIN_COUNT,
                        help="Minimal structural feature count. Default is 5."
                        )

    parser.add_argument("--wl-iterations",
                        dest="wl_iterations",
                        type=int,
                        default=DEFAULT_WL_ITERATIONS,
                        help="Number of Weisfeiler-Lehman iterations. Default is 2."
                        )

    parser.add_argument("--learning-rate",
                        dest="learning_rate",
                        type=float,
                        default=DEFAULT_LEARNING_RATE,
                        help="Initial learning rate. Default is 0.025."
                        )

    parser.add_argument("--down-sampling",
                        dest="down_sampling",
                        type=float,
                        default=DEFAULT_DOWN_SAMPLING,
                        help="Down sampling rate of features. Default is 0.0001."
                        )

    parser.add_argument('--model','-m',
                        dest="model",
                        nargs='?',
                        default=DEFAULT_MODEL_NAME,
                        help='Select the model(KNN, LR, MLP, RF, SVM).'
                        )

    parser.add_argument('--classify', '-c',
                        dest="classify",
                        action='store_true',
                        default=DEFAULT_CLASSIFY,
                        help='apply the family classifier'
                        )

    args = parser.parse_args()
    config.path.input = args.input_path
    config.path.output = args.output_path
    config.model.dimensions = args.dimensions
    config.model.workers = args.workers
    config.model.epochs = args.epochs
    config.model.min_count = args.min_count
    config.model.wl_iterations = args.wl_iterations
    config.model.learning_rate = args.learning_rate
    config.model.down_sampling = args.down_sampling
    config.model.modelName = args.model
    config.classify = args.classify

    return config

def write_config_to_file(config: Config):
    '''
    Writes the parameter settings of
    the config object to a JSON file in
    the execution folder with the
    default name `"config.json."`
    '''
    with open(CONFIG_FILE_NAME, "w", encoding="utf8") as file:
        file.write(config.json())

def detect_config_file() -> None:
    '''
    If you run Python using the IPython approach,
    the command line parsing functionality will not be enabled.
    On the other hand, if you execute Python in the regular way,
    it will utilize argparse to read the parameters passed through the command line.
    '''

    if 'ipykernel' not in sys.modules and len(sys.argv) > 1:
        logging.info(
            "Creating local config file by argparse."
        )
        write_config_to_file(parameter_parser(Config()))
        logging.info(f"{CONFIG_FILE_NAME} created!")
    elif CONFIG_FILE_NAME in os.listdir():
        logging.info(f"{CONFIG_FILE_NAME} detected!")
    else:
        logging.info(
            "config file not found. creating local config file by default config."
        )
        write_config_to_file(Config())
        logging.info(f"{CONFIG_FILE_NAME} created!")

def read_config(count=1) -> Config:
    '''
    Reads the settings from the `config.json` file.
    '''
    if count > 3:
        logging.warning("Failed to read config, returning default config")
        return Config()
    if count != 1:
        logging.info(f"Trying to read config time:{count}")
    try:
        with open(CONFIG_FILE_NAME, encoding="utf8") as file:
            return Config.parse_raw(file.read())
    except Exception as err:
        logging.warning(err)
        detect_config_file(argparse=False)
        return read_config(count=count+1)

detect_config_file()
logging.info("config.py got executed")