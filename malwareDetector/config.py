"""Load all user defined config and env vars."""

import os
import sys
import logging
import argparse

from pydantic import BaseModel, Extra
from typing import List, Any
from .const import *

class PathConfig(BaseModel, extra=Extra.allow):
    '''
    The `PathConfig` class stores the input file path
    and output file path settings for the detector,
    which are obtained from `parameter_parser()`.
    If no additional settings are provided,
    default values will be used.

    If you wish to create a customized parameter,
    there has two methods to do it.
    1. please refer to the `set_param` and `del_param`
    method of the `PathConfig` class.
    2. directly set the parameter in the `config.json` file.
    '''
    input: str = DEFAULT_INPUT_PATH
    output: str = DEFAULT_OUT_PATH
    config: str = DEFAULT_CONFIG_PATH

    def set_param(self, __name: str, __value: Any):
        if hasattr(self, __name):
            raise AttributeError(f"Parameter {__name} already exists.")
        else:
            setattr(self, __name, __value)

    def del_param(self, __name: str):
        if hasattr(self, __name):
            delattr(self, __name)

class ModelConfig(BaseModel, extra=Extra.allow):
    '''
    The `ModelConfig` class stores the
    hyperparameters of model for the detector,
    which are obtained from `parameter_parser()`.
    If no additional settings are provided,
    default values will be used.

    If you wish to create a customized parameter,
    there has two methods to do it.
    1. please refer to the `set_param` and `del_param`
    method of the `ModelConfig` class.
    2. directly set the parameter in the `config.json` file.
    '''
    modelName: str = DEFAULT_MODEL_NAME
    dimensions: int = DEFAULT_DIMENSIONS
    workers: int = DEFAULT_WORKERS
    epochs: int = DEFAULT_EPOCHS
    min_count: int = DEFAULT_MIN_COUNT
    wl_iterations: int = DEFAULT_WL_ITERATIONS
    learning_rate: float = DEFAULT_LEARNING_RATE
    down_sampling: float = DEFAULT_DOWN_SAMPLING

    def set_param(self, __name: str, __value: Any):
        if hasattr(self, __name):
            raise AttributeError(f"Parameter {__name} already exists.")
        else:
            setattr(self, __name, __value)

    def del_param(self, __name: str):
        if hasattr(self, __name):
            delattr(self, __name)

class FolderConfig(BaseModel, extra=Extra.allow):
    '''
    The `FolderConfig` class stores the names
    of folders where the stored data is kept.

    If you wish to create a customized parameter,
    there has two methods to do it.
    1. please refer to the `set_folder` and `del_folder`
    method of the `FolderConfig` class.
    2. directly set the parameter in the `config.json` file.
    '''
    dataset: str = DATASET_DIR
    feature: str = FEATURE_DIR
    vectorize: str = VECTORIZE_DIR
    model: str = MODEL_DIR
    predict: str = PREDICT_DIR

    def update_folder_list(self):
        self.folder_list = [getattr(self, folder) for folder in self.__dict__.keys()]

    def __iter__(self):
        return FolderClassIter(self.folder_list)

    def set_folder(self, __name: str, __value: str):
        if hasattr(self, __name):
            raise AttributeError(f"Folder {__name} already exists.")
        else:
            __value = f"./{__value}/"
            setattr(self, __name, __value)
            self.folder_list.append(__value)

    def del_folder(self, __name: str):
        if hasattr(self, __name):
            __value = getattr(self, __name)
            delattr(self, __name)
            if __value in self.folder_list:
                self.folder_list.remove(__value)

class FolderClassIter(object):
    '''
    `FolderClassIter` is an instance of
    an Iterator for `FolderConfig`,
    allowing users to access the contents
    of the folder list in a loop.
    '''
    def __init__(self, folder_list):
        self._folder = folder_list
        self._folder_size = len(folder_list)
        self._current_index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self._current_index < self._folder_size:
            member = self._folder[self._current_index]
            self._current_index += 1
            return member
        raise StopIteration

class Config(BaseModel, extra=Extra.allow):
    '''
    The `Config` class stores all the external settings
    for the detector, which are obtained from `parameter_parser()`.
    If no additional settings are provided, default values will be used.

    Main configuration items include:
        `PathConfig`: Stores information related to file paths.
        `FolderConfig`: Contains configurations for folders and directories.
        `ModelConfig`: Includes settings specific to the model.
        `classify`: Determines whether the task is malware family classification or simple malware detection.

    If you wish to create a customized parameter,
    there has two methods to do it.
    1. please refer to the `set_param` and `del_param`
    method of the `Config` class.
    2. directly set the parameter in the `config.json` file.
    '''
    path: PathConfig = PathConfig()
    folder: FolderConfig = FolderConfig()
    model: ModelConfig = ModelConfig()
    classify: bool = DEFAULT_CLASSIFY

    def set_param(self, __name: str, __value: Any):
        if hasattr(self, __name):
            raise AttributeError(f"Parameter {__name} already exists.")
        else:
            setattr(self, __name, __value)

    def del_param(self, __name: str):
        if hasattr(self, __name):
            delattr(self, __name)

def parameter_parser(config: Config) -> Config:
    '''
    A method for parsing command line parameters
    using `python argparse`. If not specified in
    the command line, it will use the default
    values set in `const.py`.
    '''
    parser = argparse.ArgumentParser(description="Parse command line parameters.")

    parser.add_argument("--input-path","-i",
                        dest="input_path",
                        nargs="?",
                        default=DEFAULT_INPUT_PATH,
                        help="Input folder with jsons."
                        )

    parser.add_argument("--output-path","-o",
                        dest="output_path",
                        nargs="?",
                        default=DEFAULT_OUT_PATH,
                        help="Embeddings path."
                        )

    parser.add_argument("--config-path","-c",
                        dest="config_path",
                        nargs="?",
                        default=DEFAULT_CONFIG_PATH,
                        help="Configuration file path.")

    parser.add_argument("--dimensions",
                        dest="dimensions",
                        type=int,
                        default=DEFAULT_DIMENSIONS,
                        help="Number of dimensions. Default is 128."
                        )

    parser.add_argument("--workers",
                        dest="workers",
                        type=int,
                        default=DEFAULT_WORKERS,
                        help="Number of workers. Default is 4."
                        )

    parser.add_argument("--epochs",
                        dest="epochs",
                        type=int,
                        default=DEFAULT_EPOCHS,
                        help="Number of epochs. Default is 10."
                        )

    parser.add_argument("--min-count",
                        dest="min_count",
                        type=int,
                        default=DEFAULT_MIN_COUNT,
                        help="Minimal structural feature count. Default is 5."
                        )

    parser.add_argument("--wl-iterations",
                        dest="wl_iterations",
                        type=int,
                        default=DEFAULT_WL_ITERATIONS,
                        help="Number of Weisfeiler-Lehman iterations. Default is 2."
                        )

    parser.add_argument("--learning-rate",
                        dest="learning_rate",
                        type=float,
                        default=DEFAULT_LEARNING_RATE,
                        help="Initial learning rate. Default is 0.025."
                        )

    parser.add_argument("--down-sampling",
                        dest="down_sampling",
                        type=float,
                        default=DEFAULT_DOWN_SAMPLING,
                        help="Down sampling rate of features. Default is 0.0001."
                        )

    parser.add_argument('--model','-m',
                        dest="model",
                        nargs='?',
                        default=DEFAULT_MODEL_NAME,
                        help='Select the model(KNN, LR, MLP, RF, SVM).'
                        )

    parser.add_argument('--classify', '-f',
                        dest="classify",
                        action='store_true',
                        default=DEFAULT_CLASSIFY,
                        help='apply the family classifier'
                        )

    args = parser.parse_args()
    config.path.input = args.input_path
    config.path.output = args.output_path
    config.path.config = args.config_path
    config.model.dimensions = args.dimensions
    config.model.workers = args.workers
    config.model.epochs = args.epochs
    config.model.min_count = args.min_count
    config.model.wl_iterations = args.wl_iterations
    config.model.learning_rate = args.learning_rate
    config.model.down_sampling = args.down_sampling
    config.model.modelName = args.model
    config.classify = args.classify

    return config

def write_config_to_file(config: Config, config_file_path=DEFAULT_CONFIG_PATH):
    '''
    Writes the parameter settings of the config object to a JSON file
    in the execution folder with the default path `"./config.json."`
    or you can specify the path by passing the `config_file_path` parameter.
    '''

    with open(config_file_path, "w", encoding="utf8") as file:
        file.write(config.json(exclude={"folder": {"folder_list"}}))

def detect_config_file(config_file_path=DEFAULT_CONFIG_PATH) -> None:
    '''
    If you run Python using the IPython approach,
    the command line parsing functionality will not be enabled.
    On the other hand, if you execute Python in the regular way,
    it will utilize argparse to read the parameters passed through the command line.
    default config.json will be created in the local folder if it does not exist.
    `config_file_path` is the path to the config file.
    '''

    if 'ipykernel' not in sys.modules and len(sys.argv) > 1:
        logging.info(
            "Creating local config file by argparse."
        )
        config = parameter_parser(Config())
        config_file_path = config.path.config
        write_config_to_file(config, config.path.config)
        logging.info(f"{config_file_path} created!")
    elif os.path.exists(config_file_path):
        logging.info(f"{config_file_path} detected!")
    else:
        logging.info(
            "config file not found. creating local config file by default config."
        )
        write_config_to_file(Config(), config_file_path)
        logging.info(f"{config_file_path} created!")
    return config_file_path

def read_config(config_file_path=DEFAULT_CONFIG_PATH, count=1) -> Config:
    '''
    Reads the settings from config_file_path and returns a Config object.
    '''

    if count > 3:
        logging.warning("Failed to read config, returning default config")
        return Config()
    if count != 1:
        logging.info(f"Trying to read config time:{count}")
    try:
        config_file_path = detect_config_file(config_file_path=config_file_path)
        with open(config_file_path, encoding="utf-8") as file:
            config = Config.parse_raw(file.read())
            config.folder.update_folder_list()
            return config
    except Exception as err:
        logging.warning(err)
        return read_config(config_file_path=config_file_path, count=count+1)

logging.info("config.py got executed")